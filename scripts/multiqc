#!/usr/bin/env python

""" MultiQC: A modular tool to aggregate results from bioinformatics analyses across many samples into a single report
"""

from __future__ import print_function

import base64
import io
import jinja2
import logging
import os
import re
import shutil
import sys
import traceback
import importlib

import click

from multiqc import (config, logger, __version__)
from multiqc.log import init_log, LEVELS

@click.command()
@click.argument('analysis_dir',
                    type=click.Path(exists=True),
                    nargs=-1,
                    required=True,
                    metavar="<analysis directory>"
)
@click.option('-d', '--dirs',
                    is_flag = True,
                    help = "Prepend directory to sample names"
)
@click.option('-i', '--title',
                    type = str,
                    help = "Report title"
)
@click.option('-t', '--template',
                    default = config.template,
                    type = click.Choice(config.avail_templates),
                    help = "Report template to use."
)
@click.option('-m', '--modules',
                    type = click.Choice(config.avail_modules),
                    multiple=True,
                    help = "Use only these modules."
)
@click.option('-e', '--exclude',
                    type = click.Choice(config.avail_modules),
                    multiple=True,
                    help = "Do not use these modules."
)
@click.option('-f', '--force',
                    is_flag = True,
                    help = "Overwrite any existing reports"
)
@click.option('-o', '--output_prefix',
                    type = str,
                    help = "Output filename prefix."
)
@click.option('-v', '--verbose', 
                    count=True,
                    default=0,
                    help = "Increase output verbosity."
)
@click.option('-q', '--quiet', 
                    is_flag=True,
                    help = "Only show log warnings"
)
@click.version_option(__version__)

def multiqc(analysis_dir, dirs, title, template, modules, exclude, output_prefix, 
force, verbose, quiet):
    """MultiQC is a tool generate qc reports.
    
        It can be used to create an aggregate report summarising the results
        of bioinformatics analyses across numerous samples.  
        
        To run, supply with one or more directory to scan for analysis results. 
        To run here, use 'multiqc .'
    """
    
    # Set up logging level
    loglevel = LEVELS.get(min(verbose,1), "INFO")
    if quiet:
        loglevel = 'WARNING'
    init_log(logger, loglevel=loglevel)
    
    logger.info("Working dir : {0}".format(os.getcwd()))
    logger.info("Template    : {0}".format(template))
    
    # Are we running as an OSX App?
    osx_app = False
    if os.environ.get('MULTQC_IS_APP') is not None:
        osx_app = True
        logging.basicConfig(stream=sys.stdout, format='<li>%(message)s</li>', level=20)
        with open(os.path.join(os.getcwd(), 'multiqc_app_header.html'), 'r') as f:
            print(f.read())
    
    # Weird thing that has to do with running the osx app:
    if (sys.argv[-1] == '-f' or sys.argv[-1][:4] == '-psn') and osx_app:
            print("</ul><p>Please drag your analysis directory"\
                    " here.</p><small>MultiQC version {0}</small>"\
                    "</body></html>".format(__version__))
            sys.exit(0)
    
    # Set up key variables (overwrite config vars from command line)
    config.title = title
    config.prepend_dirs = dirs
    config.analysis_dir = analysis_dir
    config.output_dir = os.path.realpath(config.output_dir)
    
    # Load the template
    template_mod = config.avail_templates[template].load()
    template_dir = template_mod.template_dir
    template_fn = template_mod.template_fn
    
    if osx_app:
        config.output_dir = os.path.join(analysis_dir, 'multiqc_report')
    
    # If output prefix has been set, prepend to config variables
    if output_prefix is not None:
        output_prefix = output_prefix.strip()
        # If we've just been given a directory, don't add the underscore
        # TODO: Better way of doing this?
        prefix = '_'
        if os.path.basename('{}{}{}'.format(output_prefix, prefix, config.output_fn_name)) == '_{}'.format(config.output_fn_name):
            prefix = ''
        config.output_fn_name = '{}{}{}'.format(output_prefix, prefix, config.output_fn_name)
        config.data_dir_name = '{}{}{}'.format(output_prefix, prefix, config.data_dir_name)
    
    # Make paths from the file names
    config.output_fn = os.path.join(config.output_dir, config.output_fn_name)
    config.data_dir = os.path.join(config.output_dir, config.data_dir_name)
    
    
    
    # Print some status updates
    if config.title is not None:
        logger.info("Report title: {0}".format(config.title))
    if dirs:
        logger.info("Prepending directory to sample names")
    logger.info("Searching   : {0}".format(', '.join(config.analysis_dir)))
    logger.debug("Output      : {0}".format(os.path.relpath(config.output_fn)))
    logger.debug("Data dir    : {0}".format(os.path.relpath(config.data_dir)))
    
    # Get the list of modules we want to run
    run_modules = config.avail_modules.keys()
    if modules:
        run_modules = [m for m in config.avail_modules.keys() if m in modules]
        logger.info('Only using modules {}'.format(', '.join(modules)))
    elif exclude:
        run_modules = [m for m in config.avail_modules.keys() if m not in exclude]
        logger.info('Excluding modules {}'.format(', '.join(exclude)))
    if len(run_modules) == 0:
        logger.critical('No analysis modules specified!')
        sys.exit(1)
    logger.debug("Analysing modules: {0}".format(', '.join(run_modules)))
    
    # Check for existing reports and remove if -f was specified
    if os.path.exists(config.output_fn) or os.path.exists(config.data_dir):
        if force:
            if os.path.exists(config.output_fn):
                logger.warning("Deleting    : {}   (-f was specified)".format(os.path.relpath(config.output_fn)))
                os.remove(config.output_fn)
            if os.path.exists(config.data_dir):
                logger.warning("Deleting    : {}   (-f was specified)".format(os.path.relpath(config.data_dir)))
                shutil.rmtree(config.data_dir)
        else:
            if os.path.exists(config.output_fn):
                logger.error("MultiQC Report {} already exists.".format(config.output_fn))
            if os.path.exists(config.data_dir):
                logger.error("Output directory {} already exists.".format(config.data_dir))
            logger.info("Use -f or --force to overwrite existing reports")
            sys.exit(1)

    logger.info("Saving to   : {}".format(os.path.relpath(config.output_fn)))

    # Make the report data directory
    os.makedirs(config.data_dir)

    # Run the modules!
    modules_output = list()
    sys_exit_code = 0
    for this_module in run_modules:
        try:
            mod = config.avail_modules[this_module].load()
            modules_output.append(mod.MultiqcModule())
        except UserWarning:
            pass # No samples found
        except:
            # Flag the error, but carry on
            logger.error("Oops! The '{}' MultiQC module broke... \n".format(this_module) + \
                      (' '*20)+"Please copy the following traceback and report it at " + \
                      "https://github.com/ewels/MultiQC/issues \n" + \
                      (' '*20)+"(if possible, include a log file that triggers the error) \n" + \
                      ('='*60)+"\nModule {} raised an exception: {}".format(
                          this_module, traceback.format_exc()) + ('='*60))
            sys_exit_code = 1

    # Did we find anything?
    if len(modules_output) == 0:
        logger.warn("No analysis results found. Cleaning up..")
        shutil.rmtree(config.data_dir)
        logger.info("MultiQC complete")
        # Exit with an error code if a module broke
        sys.exit(sys_exit_code)

    # Print the general stats table to a file
    with open (os.path.join(config.data_dir, 'multiqc_general_stats.txt'), "w") as f:
        hrow = '\t'.join([''] + list(config.general_stats['headers'].keys()) )
        l = [hrow]
        for sn, r in iter(sorted(config.general_stats['rows'].items())):
            thesefields = [sn] + [ str(r.get(k, '')) for k in config.general_stats['headers'] ]
            thesefields = [ re.sub('<[^<]+?>', '', field) for field in thesefields ]
            l.append( '\t'.join( thesefields ) )
        print( '\n'.join(l), file=f)

    # Function to include file contents in Jinja template
    def include_file(name, fdir=template_dir, b64=False):
        if b64:
            with io.open (os.path.join(fdir, name), "rb") as f:
                return base64.b64encode(f.read()).decode('utf-8')
        else:
            with io.open (os.path.join(fdir, name), "r", encoding='utf-8') as f:
                return f.read()
    
    # Load the template
    try:
        env = jinja2.Environment(loader=jinja2.FileSystemLoader(template_dir))
        env.globals['include_file'] = include_file
        j_template = env.get_template(template_fn)
    except:
        raise IOError ("Could not load template '{}'".format(template_fn))

    # Use jinja2 to render the template and overwrite
    config.analysis_dir = [os.path.realpath(d) for d in config.analysis_dir]
    report = j_template.render(config=config, modules=modules_output)
    try:
        with io.open (config.output_fn, "w", encoding='utf-8') as f:
            print(report, file=f)
    except IOError as e:
        raise IOError ("Could not print report to '{}' - {}".format(output_path, IOError(e)))

    logger.info("MultiQC complete")
    if osx_app: 
        print('</ul><p><a href="file://{}">Click here to see the MultiQC report</a>.</p><small>Resize the window first</small></body></html>'.format(config.output_fn))
    
    # Exit with an error code if a module broke
    sys.exit(sys_exit_code)
    

if __name__ == "__main__":
    multiqc()
