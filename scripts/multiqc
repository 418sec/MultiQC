#!/usr/bin/env python

""" MultiQC: A modular tool to aggregate results from bioinformatics analyses across many samples into a single report
"""

from __future__ import print_function

import argparse
import collections
import jinja2
import json
import logging
import os
import shutil
import traceback
import yaml
from datetime import datetime

# Constants
VERSION = '0.1'
MULTIQC_DIR = os.path.realpath(os.path.join(os.path.dirname(os.path.realpath(__file__)), '..'))
avail_templates = [ d for d in os.listdir(os.path.join(MULTIQC_DIR, 'templates'))
                if os.path.isdir(os.path.join(MULTIQC_DIR, 'templates', d)) ]

# This overcomplicated code finds modules from their presence in the multiqc
# directory and also tries to specify their order. It copes with missing
# modules and unexpected modules. There's probably a much more elegant way
# to do this.
mod_folders = [ d for d in os.listdir(os.path.join(MULTIQC_DIR, 'multiqc'))
                if os.path.isdir(os.path.join(MULTIQC_DIR, 'multiqc', d)) ]
module_order = ['bismark', 'cutadapt', 'fastq_screen', 'fastqc']
avail_modules = list()
for m in module_order:
    if m in mod_folders:
        avail_modules.append(m)
for m in mod_folders:
    if m not in module_order:
        avail_modules.append(m)

# Load and parse configuration file if we find it
try:
    yaml_config = os.path.join(MULTIQC_DIR, 'multiqc_config.yaml')
    with open(yaml_config) as f:
        config = yaml.load(f)
except IOError:
    config = {
        'template': 'default',
        'output_dir': 'multiqc_report'
    }

# Main function to execute MultiQC
def multiqc (analysis_dir=os.getcwd(), title=None, template=config['template'], output_dir=os.path.join(os.getcwd(), config['output_dir']), run_modules=avail_modules, force_overwrite=False):

    # Set up helper vars
    template_dir = os.path.join(MULTIQC_DIR, 'templates', template)
    template_fn = os.path.join(output_dir, 'multiqc_report.html')

    analysis_dir = os.path.realpath(analysis_dir)
    logging.info("Scanning {}".format(analysis_dir))

    # Copy the template directory to the output directory
    if os.path.exists(output_dir):
        if force_overwrite:
            logging.warning("Deleting {} because -f was specified.".format(output_dir))
            shutil.rmtree(output_dir)
            if os.path.exists("{}.zip".format(output_dir)):
                os.remove("{}.zip".format(output_dir))
        else:
            logging.error("Error - Output directory {} already exists. Use -f or --force to overwrite existing reports".format(output_dir))
            return

    logging.info("Saving to {}".format(output_dir))
    shutil.copytree(template_dir, output_dir)

    # Make the report data directory
    os.mkdir(os.path.join(output_dir, 'report_data'))

    # Create a dict with common fields
    report = {
        'title': title,
        'creation_date': datetime.now().strftime("%Y-%m-%d, %H:%m"),
        'working_dir': os.getcwd(),
        'analysis_dir': analysis_dir,
        'output_dir': output_dir,
        'general_stats': {
            'headers': collections.OrderedDict(),
            'rows': collections.defaultdict(lambda:dict())
        }
    }

    # Run the modules!
    modules_output = list()
    for m in run_modules:
        try:
            mod = __import__('multiqc.{}'.format(m), fromlist=['multiqc'])
            modules_output.append(mod.MultiqcModule(report))
        except UserWarning:
            pass # No samples found
        except:
            logging.error("Error - module {} raised an exception: {}".format(m, traceback.format_exc()))

    # Did we find anything?
    if len(modules_output) == 0:
        logging.error("Error - did not find any analysis results. Cleaning up..")
        shutil.rmtree(output_dir)
        return

    # Load the copied template
    try:
        env = jinja2.Environment(loader=jinja2.FileSystemLoader(output_dir))
        j_template = env.get_template('multiqc_report.html')
    except:
        raise IOError ("Error - could not load template '{}'".format(template_fn))

    # Use jinja2 to render the template and overwrite
    report = j_template.render(report=report, modules=modules_output)
    try:
        with open(template_fn, 'w') as f:
            print(report, file=f)
    except IOError as e:
        raise IOError ("Error printing report to '{}' - {}".format(output_path, IOError(e)))

    # Create a zip file of the report directory
    shutil.make_archive(output_dir, 'zip', output_dir)

    logging.info("MultiQC complete")





# This script is being run from the command line
if __name__ == "__main__":

    # Overwrite any of the config options specified on the command line
    parser = argparse.ArgumentParser("multiqc", description="MultiQC is a tool to create an aggregate report summarising \
        the results of bioinformatics analyses across numerous samples. To run, supply with a directory to scan for \
        analysis results. To run here, use 'multiqc .'")
    parser.add_argument('analysis_dir', metavar='<analysis directory>',
        help="Directory with analysis results to parse. Use '.' for current working directory.")
    parser.add_argument('-i', "--title", dest="title", default=None,
        help="Report title")
    parser.add_argument('-t', "--template", dest="template", default=config['template'], choices=avail_templates, metavar='TEMPLATE',
        help="Report template to use. Choose from: {}".format(', '.join(avail_templates)))
    parser.add_argument("-o", "--output_dir", dest="output_dir", default=os.path.join(os.getcwd(), config['output_dir']),
        help="Output directory. Default: {}".format(config['output_dir']))
    parser.add_argument('-m', "--module", dest="run_modules", default=avail_modules, nargs="*", choices=avail_modules, metavar='MODULE',
        help="Use only these modules. Choose from: {}".format(', '.join(avail_modules)))
    parser.add_argument("-f", "--force", dest="force_overwrite", action='store_true',
        help="Overwrite any existing reports")
    parser.add_argument('-l', '--logging', dest="loglevel", default='INFO', type=str.lower, choices=['debug', 'info', 'warning', 'error', 'critical'], metavar='LEVEL',
        help="Level of logging to be printed to the console. Choose from 'debug', 'info', 'warning', 'error', 'critical'")
    parser.add_argument("-v", "--version", dest="print_version", action='store_true',
        help="Print the version of the program and exit")
    kwargs = vars(parser.parse_args())

    # Print software version
    if kwargs['print_version']:
        os.exit("MultiQC version {}".format(VERSION))
    kwargs.pop('print_version', None)

    # Set logging level
    numeric_level = getattr(logging, kwargs['loglevel'].upper(), None)
    if not isinstance(numeric_level, int):
        raise ValueError('Invalid log level: %s' % kwargs['loglevel'])
    logging.basicConfig(level=numeric_level)
    kwargs.pop('loglevel', None)

    multiqc(**kwargs)
