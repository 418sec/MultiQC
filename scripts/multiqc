#!/usr/bin/env python

""" MultiQC: A modular tool to aggregate results from bioinformatics analyses across many samples into a single report
"""

from __future__ import print_function

import io
import jinja2
import logging
import os
import re
import shutil
import sys
import traceback
import importlib

import click

from multiqc import (config, logger, module_order, multiqc_submods, 
avail_templates, __version__)
from multiqc.utils import (check_app, get_sorted_modules)
from multiqc.log import init_log, LEVELS


@click.command()
@click.argument('analysis_dir',
                    type=click.Path(exists=True),
                    nargs=-1,
                    required=True,
                    metavar="<analysis directory>"
)
@click.option('-d', '--dirs',
                    is_flag = True,
                    help = "Prepend directory to sample names"
)
@click.option('-i', '--title',
                    type = str,
                    help = "Report title"
)
@click.option('-t', '--template',
                    default = config.template,
                    type = click.Choice(avail_templates),
                    help = "Report template to use. Choose from: {}".format(
                        ', '.join(avail_templates))
)
@click.option('-m', '--modules',
                    default = multiqc_submods,
                    type = click.Choice(multiqc_submods),
                    multiple=True,
                    help = "Use only these modules. Choose from: {}".format(
                        ', '.join(multiqc_submods))
)
@click.option('-e', '--exclude',
                    type = click.Choice(multiqc_submods),
                    multiple=True,
                    help = "Do not use these modules. Choose from: {}".format(
                        ', '.join(multiqc_submods))
)
@click.option('-f', '--force',
                    is_flag = True,
                    help = "Overwrite any existing reports"
)
@click.option('-o', '--output_prefix',
                    type = str,
                    help = "Output filename prefix."
)
@click.option('-v', '--verbose', 
                count=True,
                default=0,
                help=u"Increase output verbosity. Can be used multiple times, eg. -vv"
)
@click.option('-q', '--quiet', 
                is_flag=True,
                help=u"Set output verbosity to 'WARNING'"
)
@click.version_option(__version__)

def multiqc(analysis_dir, dirs, title, template, modules, exclude, output_prefix, 
force, verbose, quiet):
    """MultiQC is a tool generate qc reports.
    
        It can be used to create an aggregate report summarising the results
        of bioinformatics analyses across numerous samples.  
        
        To run, supply with one or more directory to scan for analysis results. 
        To run here, use 'multiqc .'
    """
    loglevel = LEVELS.get(min(verbose,1), "INFO")
    if quiet:
        loglevel = 'WARNING'
    init_log(logger, loglevel=loglevel)
    
    sorted_modules = get_sorted_modules(
        multiqc_submodules = modules, 
        module_order = module_order
    )
    
    logger.info("Working dir : {0}".format(os.getcwd()))
    logger.info("Template    : {0}".format(template))
    
    osx_app = check_app()
    
    # Weird thing that has to do with running the osx app:
    if (sys.argv[-1] == '-f' or sys.argv[-1][:4] == '-psn') and osx_app:
            print("</ul><p>Please drag your analysis directory"\
                    " here.</p><small>MultiQC version {0}</small>"\
                    "</body></html>".format(config.VERSION))
            sys.exit(0)
    
    # Set up helper vars
    template_dir = os.path.join(config.MULTIQC_DIR, 'templates', template.strip())
    config.output_dir = os.path.realpath(config.output_dir)
    config.template_fn = os.path.join(template_dir, 'multiqc_report.html')
    
    if osx_app:
        config.output_dir = os.path.join(analysis_dir, 'multiqc_report')
    
    # If output prefix has been set, prepend to config variables
    if output_prefix is not None:
        output_prefix = output_prefix.strip()
        config.output_fn_name = '{}_{}'.format(output_prefix, config.output_fn_name)
        config.data_dir_name = '{}_{}'.format(output_prefix, config.data_dir_name)
    
    # Make paths from the file names
    config.output_fn = os.path.join(config.output_dir, config.output_fn_name)
    config.data_dir = os.path.join(config.output_dir, config.data_dir_name)
    
    # Update the config with the command line options
    config.title = title
    config.prepend_dirs = dirs
    config.analysis_dir = analysis_dir
    
    # Print some status updates
    if config.title is not None:
        logger.info("Report title: {0}".format(title))
    if dirs:
        logger.info("Prepending directory to sample names")
    logger.info("Searching   : {0}".format(', '.join(config.analysis_dir)))
    logger.debug("Output      : {0}".format(os.path.relpath(config.output_fn)))
    logger.debug("Data dir    : {0}".format(os.path.relpath(config.data_dir)))
    
    run_modules = sorted_modules
    # exclude modules
    if exclude:
        logger.info('Excluding modules {}'.format(', '.join(exclude)))
        run_modules = [mod for mod in run_modules if mod not in exclude]
    
    logger.debug("Analysing modules {0}".format(', '.join(run_modules)))
    
    # Copy the template directory to the output directory
    if os.path.exists(config.output_fn) or os.path.exists(config.data_dir):
        if force:
            if os.path.exists(config.output_fn):
                logger.warning("Deleting    : {}   (-f was specified)".format(os.path.relpath(config.output_fn)))
                os.remove(config.output_fn)
            if os.path.exists(config.data_dir):
                logger.warning("Deleting    : {}   (-f was specified)".format(os.path.relpath(config.data_dir)))
                shutil.rmtree(config.data_dir)
        else:
            if os.path.exists(config.output_fn):
                logger.error("MultiQC Report {} already exists.".format(config.output_fn))
            if os.path.exists(config.data_dir):
                logger.error("Output directory {} already exists.".format(config.data_dir))
            logger.info("Use -f or --force to overwrite existing reports")
            sys.exit(1)

    logger.info("Saving to   : {}".format(os.path.relpath(config.output_fn)))

    # Make the report data directory
    os.makedirs(config.data_dir)

    # Run the modules!
    modules_output = list()
    sys_exit_code = 0
    for this_module in run_modules:
        try:
            mod = importlib.import_module("multiqc.modules.{0}".format(this_module))
            modules_output.append(mod.MultiqcModule())
        except UserWarning:
            pass # No samples found
        except:
            # Flag the error, but carry on
            logger.error("Oops! The '{}' MultiQC module broke... \n".format(this_module) + \
                      (' '*20)+"Please copy the following traceback and report it at " + \
                      "https://github.com/ewels/MultiQC/issues \n" + \
                      (' '*20)+"(if possible, include a log file that triggers the error) \n" + \
                      ('='*60)+"\nModule {} raised an exception: {}".format(
                          this_module, traceback.format_exc()) + ('='*60))
            sys_exit_code = 1

    # Did we find anything?
    if len(modules_output) == 0:
        logger.warn("No analysis results found. Cleaning up..")
        shutil.rmtree(config.data_dir)
        logger.info("MultiQC complete")
        # Exit with an error code if a module broke
        sys.exit(sys_exit_code)

    # Print the general stats table to a file
    with open (os.path.join(config.data_dir, 'multiqc_general_stats.txt'), "w") as f:
        hrow = '\t'.join([''] + list(config.general_stats['headers'].keys()) )
        l = [hrow]
        for sn, r in iter(sorted(config.general_stats['rows'].items())):
            thesefields = [sn] + [ str(r.get(k, '')) for k in config.general_stats['headers'] ]
            thesefields = [ re.sub('<[^<]+?>', '', field) for field in thesefields ]
            l.append( '\t'.join( thesefields ) )
        print( '\n'.join(l), file=f)

    # Function to include file contents in Jinja template
    def include_file(name, fdir=template_dir, base64=False):
        if base64:
            with open (os.path.join(fdir, name), "rb") as f:
                return f.read().encode('base64').replace('\n', '')
        else:
            with io.open (os.path.join(fdir, name), "r", encoding='utf-8') as f:
                return f.read()
    
    # Load the copied template
    try:
        env = jinja2.Environment(loader=jinja2.FileSystemLoader(template_dir))
        env.globals['include_file'] = include_file
        j_template = env.get_template('multiqc_report.html')
    except:
        raise IOError ("Could not load template '{}'".format(config.template_fn))

    # Use jinja2 to render the template and overwrite
    config.analysis_dir = [os.path.realpath(d) for d in config.analysis_dir]
    report = j_template.render(config=config, modules=modules_output)
    try:
        with open(config.output_fn, 'w') as f:
            print(report.encode('utf8'), file=f)
    except IOError as e:
        raise IOError ("Could not print report to '{}' - {}".format(output_path, IOError(e)))

    logger.info("MultiQC complete")
    if osx_app: 
        print('</ul><p><a href="file://{}">Click here to see the MultiQC report</a>.</p><small>Resize the window first</small></body></html>'.format(config.output_fn))
    
    # Exit with an error code if a module broke
    sys.exit(sys_exit_code)
    

if __name__ == "__main__":
    multiqc()
